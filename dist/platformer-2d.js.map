{"version":3,"sources":["webpack://platformer-2d/webpack/universalModuleDefinition","webpack://platformer-2d/./lib/helpers/common-methods.ts","webpack://platformer-2d/./lib/objects/basic-object.ts","webpack://platformer-2d/./lib/objects/entity-object.ts","webpack://platformer-2d/./lib/objects/player/player.object.ts","webpack://platformer-2d/./lib/objects/wall/wall.object.ts","webpack://platformer-2d/./lib/services/canvas.service.ts","webpack://platformer-2d/./lib/services/config.service.ts","webpack://platformer-2d/./lib/services/game-loop.service.ts","webpack://platformer-2d/./lib/services/grid.service.ts","webpack://platformer-2d/./lib/services/image.service.ts","webpack://platformer-2d/./lib/services/object.service.ts","webpack://platformer-2d/webpack/bootstrap","webpack://platformer-2d/webpack/runtime/define property getters","webpack://platformer-2d/webpack/runtime/hasOwnProperty shorthand","webpack://platformer-2d/webpack/runtime/make namespace object","webpack://platformer-2d/./lib/index.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;;;ACPO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpBgD;AACH;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,sDAAW;AAC7C;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7GgD;AACzC,qBAAqB,wDAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9E8C;AACvC,mBAAmB,sDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACXA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB,sCAAsC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5DO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,+CAA+C;AAC/C,kDAAkD;AAClD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5B8D;AACvD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0EAAiB;AACrC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2BAA2B;AACjE,0CAA0C,2BAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC/DA;AACoD;AACM;AACU;AACF;AACE;AACA;AACA;AACF;AACE;AACA;AACJ;AACzD;AACP;AACA;AACA;AACA,gCAAgC,uDAAQ;AACxC,mCAAmC,0DAAW;AAC9C;AACA;AACA;AACA,iCAAiC,mEAAY;AAC7C,gCAAgC,kEAAW;AAC3C;AACA,8BAA8B,mEAAY;AAC1C,8BAA8B,mEAAY;AAC1C;AACA,aAAa;AACb;AACA,iCAAiC,mEAAY;AAC7C,gCAAgC,kEAAW;AAC3C;AACA,8BAA8B,mEAAY;AAC1C,8BAA8B,mEAAY;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,iEAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvDgD;AACS;AACN;AACN;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAW;AAC1C;AACA;AACA;AACA;AACA,0BAA0B,iEAAM;AAChC;AACA;AACA;AACA,gDAAgD,2DAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAG,OAAO,4DAAG;AACzC,4BAA4B,4DAAG,OAAO,4DAAG;AACzC,gBAAgB,4DAAG,YAAY,4DAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCzHA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;;;;;;;ACNsD;AACE;AACE;AACK;AACL;AAC3C;AACf;AACA,gCAAgC,iEAAY;AAC5C,iCAAiC,mEAAa;AAC9C;AACA,iCAAiC,6DAAa;AAC9C,iCAAiC,mEAAa;AAC9C,mCAAmC,wEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA","file":"dist/platformer-2d.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Platformer2D\"] = factory();\n\telse\n\t\troot[\"Platformer2D\"] = factory();\n})(self, function() {\nreturn ","export function swapArrayElements(array, index1, index2) {\r\n    array[index2] = array.splice(index1, 1, array[index2])[0];\r\n}\r\nexport function abs(num) {\r\n    if (num < 0)\r\n        return -num;\r\n    return num;\r\n}\r\n","export class BasicObject {\r\n    constructor(config, canvasService) {\r\n        this.canvasService = canvasService;\r\n        this.relatedCells = [];\r\n        this.isModelFlipped = false;\r\n        this.reverseModel = false;\r\n        this.coords = config.coords;\r\n        this.size = config.size;\r\n    }\r\n    drawObject() {\r\n        const modelCoords = [\r\n            this.coords[0] + this.model.offset[0],\r\n            this.coords[1] + this.model.offset[1],\r\n            ...this.model.size\r\n        ];\r\n        if ((!this.isModelFlipped && !this.reverseModel) || (this.isModelFlipped && this.reverseModel))\r\n            this.canvasService.drawImage(this.model.image, modelCoords);\r\n        else\r\n            this.canvasService.drawFlippedImage(this.model.image, modelCoords);\r\n    }\r\n}\r\n","import { abs } from \"../helpers/common-methods\";\r\nimport { BasicObject } from \"./basic-object\";\r\nconst DEFAULT_CONFIG = {\r\n    maxSpeed: 100,\r\n    sideAcceleration: 0.2,\r\n    gravity: 2000,\r\n    maxFallSpeed: 2000,\r\n    jumpPower: 800\r\n};\r\nexport class EntityObject extends BasicObject {\r\n    constructor(config, canvasService) {\r\n        super(config, canvasService);\r\n        this.vx = 0; // X-axis speed (in pixels per second)\r\n        this.vy = 0; // Y-axis speed (in pixels per second)\r\n        this.entityConfig = DEFAULT_CONFIG;\r\n        this.sideButtonPressed = false;\r\n        this.jumpButtonPressed = false;\r\n        this.inAir = false;\r\n    }\r\n    // TODO: Don't let player to go out of bounds\r\n    moveRight() {\r\n        this.sideButtonPressed = true;\r\n        this.isModelFlipped = false;\r\n        if (this.vx < 0)\r\n            this.vx = -this.slowDown(this.vx);\r\n        else\r\n            this.vx = this.speedUp(this.vx);\r\n        this.coords[0] = this.coords[0] + this.vx / this.fps;\r\n    }\r\n    moveLeft() {\r\n        this.sideButtonPressed = true;\r\n        this.isModelFlipped = true;\r\n        if (this.vx > 0)\r\n            this.vx = this.slowDown(this.vx);\r\n        else\r\n            this.vx = -this.speedUp(this.vx);\r\n        this.coords[0] = this.coords[0] + this.vx / this.fps;\r\n    }\r\n    jump() {\r\n        if (!this.inAir) {\r\n            this.jumpButtonPressed = true;\r\n            this.inAir = true;\r\n            this.vy = this.entityConfig.jumpPower;\r\n            this.coords[1] = this.coords[1] - this.vy / this.fps;\r\n        }\r\n    }\r\n    updateState(fps) {\r\n        this.fps = fps;\r\n        if (!this.sideButtonPressed)\r\n            this._stop();\r\n        if (!this.jumpButtonPressed)\r\n            this._fall();\r\n        this.sideButtonPressed = false;\r\n        this.jumpButtonPressed = false;\r\n    }\r\n    ;\r\n    setEntityConfig(entityConfig) {\r\n        this.entityConfig = Object.assign(Object.assign({}, DEFAULT_CONFIG), entityConfig);\r\n    }\r\n    stopFalling() {\r\n        this.inAir = false;\r\n        this.vy = 0;\r\n    }\r\n    startFalling() {\r\n        this.vy = this.applyGravity(0);\r\n    }\r\n    resetSideAcceleration() {\r\n        this.vx = 0;\r\n    }\r\n    /****************** Execute this if no buttons pressed *********************/\r\n    _stop() {\r\n        if (this.vx === 0)\r\n            return;\r\n        if (this.vx > 0)\r\n            this.vx = this.slowDown(this.vx);\r\n        else\r\n            this.vx = -this.slowDown(this.vx);\r\n        this.coords[0] = this.coords[0] + this.vx / this.fps;\r\n    }\r\n    _fall() {\r\n        // if (!this.inAir) return;\r\n        this.inAir = true;\r\n        this.vy = this.applyGravity(this.vy);\r\n        this.coords[1] = this.coords[1] - this.vy / this.fps;\r\n    }\r\n    /****************** Helpers *********************/\r\n    applyGravity(vy) {\r\n        const ySpeed = vy - this.entityConfig.gravity / this.fps;\r\n        if (-ySpeed > this.entityConfig.maxFallSpeed)\r\n            return -this.entityConfig.maxFallSpeed;\r\n        else\r\n            return ySpeed;\r\n    }\r\n    speedUp(currSpeed) {\r\n        const speed = abs(currSpeed);\r\n        const newSpeed = speed + this.entityConfig.maxSpeed / (this.fps * this.entityConfig.sideAcceleration);\r\n        if (newSpeed > this.entityConfig.maxSpeed)\r\n            return this.entityConfig.maxSpeed;\r\n        else\r\n            return newSpeed;\r\n    }\r\n    slowDown(currSpeed) {\r\n        const speed = abs(currSpeed);\r\n        const newSpeed = speed - this.entityConfig.maxSpeed / (this.fps * this.entityConfig.sideAcceleration);\r\n        if (newSpeed < 0)\r\n            return 0;\r\n        else\r\n            return newSpeed;\r\n    }\r\n}\r\n","import { EntityObject } from \"../entity-object\";\r\nexport class Player extends EntityObject {\r\n    constructor(config, canvasService, imageService) {\r\n        super(config, canvasService);\r\n        this.hasCollision = true;\r\n        this.pressedDirection = null;\r\n        this.isLeftPressed = false;\r\n        this.isRightPressed = false;\r\n        this.isJumpPressed = false;\r\n        this.setEntityConfig({\r\n            maxSpeed: 350\r\n        });\r\n        this.textures = imageService.players[config.model.name];\r\n        config.coords[1] = config.coords[1] * 1.4;\r\n        config.size[1] = config.size[1] * 1.4;\r\n        this.model = {\r\n            image: this.textures.stand,\r\n            offset: config.model.offset,\r\n            size: [config.model.size[0], config.model.size[1] * 1.4]\r\n        };\r\n        this.initEventListeners();\r\n    }\r\n    updateState(fps) {\r\n        switch (this.pressedDirection) {\r\n            case 'left':\r\n                super.moveLeft();\r\n                break;\r\n            case 'right':\r\n                super.moveRight();\r\n                break;\r\n        }\r\n        if (this.isJumpPressed)\r\n            super.jump();\r\n        super.updateState(fps);\r\n    }\r\n    initEventListeners() {\r\n        document.addEventListener('keydown', e => {\r\n            switch (e.key) {\r\n                case 'ArrowRight':\r\n                    this.isRightPressed = true;\r\n                    this.updateDirection();\r\n                    break;\r\n                case 'ArrowLeft':\r\n                    this.isLeftPressed = true;\r\n                    this.updateDirection();\r\n                    break;\r\n                case 'ArrowUp':\r\n                    this.isJumpPressed = true;\r\n                    break;\r\n            }\r\n        });\r\n        document.addEventListener('keyup', e => {\r\n            switch (e.key) {\r\n                case 'ArrowRight':\r\n                    this.isRightPressed = false;\r\n                    this.updateDirection();\r\n                    break;\r\n                case 'ArrowLeft':\r\n                    this.isLeftPressed = false;\r\n                    this.updateDirection();\r\n                    break;\r\n                case 'ArrowUp':\r\n                    this.isJumpPressed = false;\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    updateDirection() {\r\n        if (this.isLeftPressed && !this.isRightPressed) {\r\n            this.pressedDirection = 'left';\r\n        }\r\n        else if (!this.isLeftPressed && this.isRightPressed) {\r\n            this.pressedDirection = 'right';\r\n        }\r\n        else if (!this.isLeftPressed && !this.isRightPressed) {\r\n            this.pressedDirection = null;\r\n        }\r\n    }\r\n}\r\n","import { BasicObject } from \"../basic-object\";\r\nexport class Wall extends BasicObject {\r\n    constructor(config, canvasService, imageService) {\r\n        super(config, canvasService);\r\n        this.hasCollision = true;\r\n        this.model = {\r\n            image: imageService.static[config.model.name],\r\n            offset: config.model.offset,\r\n            size: config.model.size\r\n        };\r\n    }\r\n}\r\n","// icons https://www.studio-maximus.com/works/apps/birds-to-space/\r\nexport default class CanvasService {\r\n    constructor(canvasElement, config, imageService) {\r\n        this.translation = {\r\n            h: 0,\r\n            v: 0\r\n        };\r\n        this.backgroundImage = imageService.background.background1;\r\n        this.element = canvasElement;\r\n        this.canvas = Object.assign(Object.assign({}, config.canvas), { ctx: canvasElement.getContext('2d') });\r\n        this.map = {\r\n            width: config.map.width,\r\n            height: config.map.height\r\n        };\r\n        this.element.width = this.canvas.width;\r\n        this.element.height = this.canvas.height;\r\n        this.breakpoints = config.camera;\r\n    }\r\n    updateCameraTranslation(x, y, w, h) {\r\n        // Horizontal translation\r\n        let transX;\r\n        if (this.translation.h + this.breakpoints.left > x) {\r\n            transX = this.translation.h - (this.breakpoints.left + this.translation.h - x);\r\n        }\r\n        else if (this.translation.h + this.canvas.width - this.breakpoints.right < x + w) {\r\n            transX = this.translation.h + (x + w - (this.translation.h + this.canvas.width - this.breakpoints.right));\r\n        }\r\n        if (transX != null && transX != this.translation.h && transX >= 0 && transX <= this.map.width - this.canvas.width) {\r\n            this.canvas.ctx.translate(this.translation.h - transX, 0);\r\n            this.translation.h = transX;\r\n        }\r\n        // Vertical translation\r\n        let transY;\r\n        if (this.translation.v + this.breakpoints.top > y) {\r\n            transY = this.translation.v - (this.breakpoints.top + this.translation.v - y);\r\n        }\r\n        else if (this.translation.v + this.canvas.height - this.breakpoints.bottom < y + h) {\r\n            transY = this.translation.v + (y + h - (this.translation.v + this.canvas.height - this.breakpoints.bottom));\r\n        }\r\n        if (transY != null && transY >= 0 && transY <= this.map.height - this.canvas.height) {\r\n            this.canvas.ctx.translate(0, this.translation.v - transY);\r\n            this.translation.v = transY;\r\n        }\r\n    }\r\n    clearCanvas() {\r\n        this.canvas.ctx.drawImage(this.backgroundImage, 0 + this.translation.h, 0 + this.translation.v, this.canvas.width, this.canvas.height);\r\n    }\r\n    drawImage(img, coords) {\r\n        this.canvas.ctx.drawImage(img, ...coords);\r\n    }\r\n    drawFlippedImage(img, coords) {\r\n        this.canvas.ctx.translate(coords[0] + coords[2], coords[1]);\r\n        this.canvas.ctx.scale(-1, 1);\r\n        this.canvas.ctx.drawImage(img, 0, 0, coords[2], coords[3]);\r\n        this.canvas.ctx.setTransform(1, 0, 0, 1, -this.translation.h, -this.translation.v);\r\n    }\r\n    drawFPS(fps) {\r\n        this.canvas.ctx.font = '14px sans-serif';\r\n        this.canvas.ctx.fillText('FPS: ' + fps, 0 + this.translation.h, 14 + this.translation.v);\r\n    }\r\n}\r\n","export class ConfigService {\r\n    constructor(config) {\r\n        this.config = this.applyDefaultConfig(config);\r\n        this.parsedConfig = this.parseConfig(this.config);\r\n    }\r\n    getParsedConfig() {\r\n        return this.parsedConfig;\r\n    }\r\n    parseConfig(config) {\r\n        const parsedConfig = {\r\n            canvas: Object.assign({}, config.canvas),\r\n            map: {\r\n                width: config.map.width * config.map.cellSize,\r\n                height: config.map.height * config.map.cellSize,\r\n                cells: {\r\n                    size: config.map.cellSize,\r\n                    horizontal: config.map.width,\r\n                    vertical: config.map.height\r\n                }\r\n            },\r\n            camera: this.getParsedCameraConfig(config),\r\n            player: this.getParsedObjectConfig(config.player, config),\r\n            objects: config.objects.map(obj => this.getParsedObjectConfig(obj, config))\r\n        };\r\n        return parsedConfig;\r\n    }\r\n    getParsedObjectConfig(obj, config) {\r\n        const parsedConfig = {\r\n            type: obj.type,\r\n            coords: [obj.coords[0] * config.map.cellSize, obj.coords[1] * config.map.cellSize],\r\n            size: [config.map.cellSize, config.map.cellSize],\r\n            model: {\r\n                name: obj.model,\r\n                offset: [0, 0],\r\n                size: [config.map.cellSize, config.map.cellSize]\r\n            }\r\n        };\r\n        return parsedConfig;\r\n    }\r\n    getParsedCameraConfig(config) {\r\n        const breakpoints = {\r\n            top: getPoint(config.canvas.height, config.camera.top),\r\n            right: getPoint(config.canvas.width, config.camera.right),\r\n            bottom: getPoint(config.canvas.height, config.camera.bottom),\r\n            left: getPoint(config.canvas.width, config.camera.left)\r\n        };\r\n        return breakpoints;\r\n        function getPoint(x, y) {\r\n            const [a, b] = y.split(':');\r\n            return x / parseInt(b) * parseInt(a);\r\n        }\r\n    }\r\n    /************** DEFAULT CONFIG **************/\r\n    applyDefaultConfig(config) {\r\n        const def = this.getDefaultConfig();\r\n        return {\r\n            canvas: Object.assign(Object.assign({}, def.canvas), config.canvas),\r\n            map: Object.assign(Object.assign({}, def.map), config.map),\r\n            camera: Object.assign(Object.assign({}, def.camera), config.camera),\r\n            player: Object.assign({}, config.player),\r\n            objects: [...def.objects, ...config.objects]\r\n        };\r\n    }\r\n    getDefaultConfig() {\r\n        return {\r\n            canvas: {\r\n                width: 900,\r\n                height: 600\r\n            },\r\n            map: {\r\n                width: 20,\r\n                height: 10,\r\n                cellSize: 70,\r\n            },\r\n            camera: {\r\n                top: '1:4',\r\n                right: '1:2',\r\n                bottom: '1:4',\r\n                left: '1:4',\r\n            },\r\n            player: null,\r\n            objects: []\r\n        };\r\n    }\r\n}\r\n","export class GameLoopService {\r\n    constructor(canvasService, objectService) {\r\n        this.canvasService = canvasService;\r\n        this.objectService = objectService;\r\n        this.isGamePaused = false;\r\n    }\r\n    start() {\r\n        this.isGamePaused = false;\r\n        this.frameStart = performance.now();\r\n        this.step();\r\n    }\r\n    stop() {\r\n        this.isGamePaused = true;\r\n    }\r\n    // Methods that should be executed during single game frame\r\n    frame() {\r\n        this.canvasService.clearCanvas();\r\n        this.objectService.renderObjects(this.fps);\r\n        this.canvasService.drawFPS(this.fps);\r\n    }\r\n    step() {\r\n        const frameEnd = performance.now();\r\n        this.fps = Math.floor(1000 / (frameEnd - this.frameStart));\r\n        this.frameStart = performance.now();\r\n        this.frame();\r\n        if (!this.isGamePaused)\r\n            setTimeout(() => this.step(), 0);\r\n    }\r\n}\r\n","import { swapArrayElements } from \"../helpers/common-methods\";\r\nexport class GridService {\r\n    constructor(map) {\r\n        this.map = map;\r\n        this.grid = {};\r\n        this.resetGrid();\r\n    }\r\n    getNeighbors(object) {\r\n        const output = new Set();\r\n        object.relatedCells.forEach(index => {\r\n            this.grid[index].forEach(o => {\r\n                if (o !== object)\r\n                    output.add(o);\r\n            });\r\n        });\r\n        return Array.from(output);\r\n    }\r\n    updateObjectPosition(o) {\r\n        this.removeObjectFromGrid(o);\r\n        this.addObjectToGrid(o);\r\n    }\r\n    // TODO: Check if it faster not remove/add all items, but update only changed items\r\n    removeObjectFromGrid(object) {\r\n        object.relatedCells.forEach(index => {\r\n            for (let [i, obj] of this.grid[index].entries()) {\r\n                if (obj === object) {\r\n                    // Swap our object with the last item in array and then remove last item (performance hack)\r\n                    swapArrayElements(this.grid[index], i, this.grid[index].length - 1);\r\n                    this.grid[index].pop();\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        object.relatedCells = [];\r\n    }\r\n    addObjectToGrid(object) {\r\n        const relatedCells = this.getRelatedCells(object.coords, object.size);\r\n        relatedCells.forEach(index => this.grid[index].push(object));\r\n        object.relatedCells = relatedCells;\r\n    }\r\n    resetGrid() {\r\n        const cells = this.getRelatedCells([0, 0], [this.map.width, this.map.height]);\r\n        cells.forEach(index => this.grid[index] = []);\r\n    }\r\n    getRelatedCells(coords, size) {\r\n        const topLeftCorner = this.getCellCoords(coords);\r\n        const bottomRightCorner = this.getCellCoords([coords[0] + size[0], coords[1] + size[1]]);\r\n        const output = [];\r\n        for (let x = topLeftCorner[0]; x <= bottomRightCorner[0]; x++) {\r\n            for (let y = topLeftCorner[1]; y <= bottomRightCorner[1]; y++) {\r\n                output.push(this.getCellIndex([x, y]));\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n    getCellCoords(objCoords) {\r\n        const x = Math.floor(objCoords[0] / this.map.cells.size);\r\n        const y = Math.floor(objCoords[1] / this.map.cells.size);\r\n        return [x, y];\r\n    }\r\n    getCellIndex(cellCoords) {\r\n        return cellCoords[0] + 'x' + cellCoords[1];\r\n    }\r\n}\r\n","// 1) Import image\r\nimport grassMid from '../assets/grass/grassMid.svg';\r\nimport grassCenter from '../assets/grass/grassCenter.svg';\r\nimport alien1_stand from '../assets/player/alien1/alien1_stand.svg';\r\nimport alien1_jump from '../assets/player/alien1/alien1_jump.svg';\r\nimport alien1_walk1 from '../assets/player/alien1/alien1_walk1.svg';\r\nimport alien1_walk2 from '../assets/player/alien1/alien1_walk2.svg';\r\nimport alien2_stand from '../assets/player/alien2/alien2_stand.svg';\r\nimport alien2_jump from '../assets/player/alien2/alien2_jump.svg';\r\nimport alien2_walk1 from '../assets/player/alien2/alien2_walk1.svg';\r\nimport alien2_walk2 from '../assets/player/alien2/alien2_walk2.svg';\r\nimport background1 from '../assets/backgrounds/background1.svg';\r\nexport class ImageService {\r\n    constructor() {\r\n        // 3) Load image to files object\r\n        this.static = {\r\n            grassMid: this.load(grassMid),\r\n            grassCenter: this.load(grassCenter)\r\n        };\r\n        this.players = {\r\n            alien1: {\r\n                stand: this.load(alien1_stand),\r\n                jump: this.load(alien1_jump),\r\n                walk: [\r\n                    this.load(alien1_walk1),\r\n                    this.load(alien1_walk2)\r\n                ]\r\n            },\r\n            alien2: {\r\n                stand: this.load(alien2_stand),\r\n                jump: this.load(alien2_jump),\r\n                walk: [\r\n                    this.load(alien2_walk1),\r\n                    this.load(alien2_walk2)\r\n                ]\r\n            }\r\n        };\r\n        this.background = {\r\n            background1: this.load(background1)\r\n        };\r\n        this.filesCount = 0;\r\n        this.loadedFilesCount = 0;\r\n        this.isLoaded = new Promise(res => this.finishLoading = res);\r\n    }\r\n    load(file) {\r\n        ++this.filesCount;\r\n        const img = new Image();\r\n        img.onload = this.fileLoaded.bind(this);\r\n        img.src = file;\r\n        return img;\r\n    }\r\n    fileLoaded() {\r\n        if (++this.loadedFilesCount >= this.filesCount)\r\n            this.finishLoading();\r\n    }\r\n}\r\n","import { abs } from \"../helpers/common-methods\";\r\nimport { Player } from \"../objects/player/player.object\";\r\nimport { Wall } from \"../objects/wall/wall.object\";\r\nimport { GridService } from \"./grid.service\";\r\nexport class ObjectService {\r\n    constructor(imageService, canvasService, config) {\r\n        this.imageService = imageService;\r\n        this.canvasService = canvasService;\r\n        this.staticObjects = [];\r\n        this.dynamicObjects = [];\r\n        this.map = {\r\n            width: config.map.width,\r\n            height: config.map.height,\r\n        };\r\n        this.gridService = new GridService(config.map);\r\n        this.init(config);\r\n    }\r\n    init(config) {\r\n        this.clearObjects();\r\n        this.player = new Player(config.player, this.canvasService, this.imageService);\r\n        for (let obj of config.objects) {\r\n            switch (obj.type) {\r\n                case 'wall':\r\n                    this.staticObjects.push(new Wall(obj, this.canvasService, this.imageService));\r\n                    break;\r\n            }\r\n        }\r\n        this.staticObjects.forEach(o => this.gridService.addObjectToGrid(o));\r\n    }\r\n    renderObjects(fps) {\r\n        /* Static objects render */\r\n        this.staticObjects.forEach(o => o.drawObject());\r\n        /* Player render */\r\n        this.renderDynamicObject(this.player, fps);\r\n        this.canvasService.updateCameraTranslation(...this.player.coords, ...this.player.size);\r\n        /* Dynamic objects render */\r\n        this.dynamicObjects.forEach(o => {\r\n            this.renderDynamicObject(o, fps);\r\n        });\r\n    }\r\n    renderDynamicObject(object, fps) {\r\n        object.updateState(fps);\r\n        this.checkBounds(object);\r\n        this.gridService.updateObjectPosition(object);\r\n        this.checkAllCollisions(object, this.gridService.getNeighbors(object));\r\n        object.drawObject();\r\n    }\r\n    clearObjects() {\r\n        this.staticObjects = [];\r\n        this.dynamicObjects = [];\r\n    }\r\n    get allObjects() {\r\n        return [...this.staticObjects, ...this.dynamicObjects];\r\n    }\r\n    checkBounds(obj) {\r\n        let [x, y] = obj.coords;\r\n        if (x < 0) {\r\n            x = 0;\r\n            obj.resetSideAcceleration();\r\n        }\r\n        else if (x + obj.size[0] > this.map.width) {\r\n            x = this.map.width - obj.size[0];\r\n            obj.resetSideAcceleration();\r\n        }\r\n        if (y < 0) {\r\n            y = 0;\r\n            obj.startFalling();\r\n        }\r\n        else if (y + obj.size[1] > this.map.height) {\r\n            y = this.map.height - obj.size[1];\r\n            obj.stopFalling();\r\n        }\r\n        obj.coords = [x, y];\r\n    }\r\n    checkAllCollisions(obj, objectsAround) {\r\n        let hasOverlaps = false;\r\n        objectsAround.forEach(o => this.checkCollision(obj, o) ? hasOverlaps = true : null);\r\n        if (hasOverlaps)\r\n            this.gridService.updateObjectPosition(obj);\r\n    }\r\n    checkCollision(o1, o2) {\r\n        // if o1 overlaps with o2, then o1 will be moved out from o2\r\n        // P.S. This function is hell for debugging :)\r\n        let [o1_x1, o1_y1] = o1.coords;\r\n        const [o1_x2, o1_y2] = [o1.coords[0] + o1.size[0], o1.coords[1] + o1.size[1]];\r\n        const [o2_x1, o2_y1] = o2.coords;\r\n        const [o2_x2, o2_y2] = [o2.coords[0] + o2.size[0], o2.coords[1] + o2.size[1]];\r\n        // Check horizontal overlaps\r\n        let horizontalOverlap = false;\r\n        const h1 = o1_x2 - o2_x1;\r\n        const h2 = o1_x1 - o2_x2;\r\n        if ((h1 < 0 && h2 > 0) || (h1 > 0 && h2 < 0))\r\n            horizontalOverlap = true;\r\n        // Check vertical overlaps\r\n        let verticalOverlap = false;\r\n        const v1 = o1_y2 - o2_y1;\r\n        const v2 = o1_y1 - o2_y2;\r\n        if ((v1 < 0 && v2 > 0) || (v1 > 0 && v2 < 0))\r\n            verticalOverlap = true;\r\n        // If overlaps in all axes\r\n        if (verticalOverlap && horizontalOverlap) {\r\n            const hOffset = abs(h1) < abs(h2) ? h1 : h2;\r\n            const vOffset = abs(v1) < abs(v2) ? v1 : v2;\r\n            if (abs(hOffset) < abs(vOffset)) {\r\n                o1_x1 -= hOffset;\r\n                o1.resetSideAcceleration();\r\n            }\r\n            else {\r\n                o1_y1 -= vOffset;\r\n                if (vOffset > 0) {\r\n                    o1.stopFalling();\r\n                }\r\n                else {\r\n                    o1.startFalling();\r\n                }\r\n            }\r\n            o1.coords = [o1_x1, o1_y1];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import CanvasService from \"./services/canvas.service\";\r\nimport { ImageService } from \"./services/image.service\";\r\nimport { ObjectService } from \"./services/object.service\";\r\nimport { GameLoopService } from \"./services/game-loop.service\";\r\nimport { ConfigService } from \"./services/config.service\";\r\nexport default class Platformer2D {\r\n    constructor(canvas, config) {\r\n        this.imageService = new ImageService();\r\n        this.configService = new ConfigService(config);\r\n        this.config = this.configService.getParsedConfig();\r\n        this.canvasService = new CanvasService(canvas, this.config, this.imageService);\r\n        this.objectService = new ObjectService(this.imageService, this.canvasService, this.config);\r\n        this.gameLoopService = new GameLoopService(this.canvasService, this.objectService);\r\n        this.imageService.isLoaded.then(() => this.init());\r\n    }\r\n    init() {\r\n        this.gameLoopService.start();\r\n    }\r\n}\r\n;\r\n"],"sourceRoot":""}